<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Ticket Summarizer</title>
  <script src="https://static.zdassets.com/zendesk_app_framework_sdk/2.0/zaf_sdk.min.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 13px;
      padding: 12px;
    }

    h3 {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 16px;
    }

    h4 {
      margin-bottom: 8px;
      margin-top: 16px;
      font-size: 14px;
    }

    .tone-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tone-pill {
      border: 1px solid #d8dcde;
      border-radius: 16px;
      padding: 6px 12px;
      cursor: pointer;
      background: #f8f9f9;
      user-select: none;
      font-size: 12px;
    }

    .tone-pill input {
      display: none;
    }

    .tone-pill:has(input:checked) {
      background: #1f73b7;
      color: white;
      border-color: #1f73b7;
    }

    .primary-btn {
      background: #1f73b7;
      color: white;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      width: 100%;
      font-size: 13px;
      margin-top: 8px;
      border: none;
    }

    .primary-btn:disabled {
      background: #c2d4e8;
      cursor: not-allowed;
    }

    .secondary-btn {
      margin-top: 6px;
      width: 100%;
      border: 1px solid #d8dcde;
      background: white;
      border-radius: 4px;
      padding: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .secondary-btn:hover {
      background: #f8f9f9;
    }

    .secondary-btn:disabled {
      background: #f0f0f0;
      cursor: not-allowed;
      color: #999;
    }

    .reply-container {
      margin-top: 10px;
    }

    #replyBox {
      background: #f8f9f9;
      border: 1px solid #d8dcde;
      border-radius: 4px;
      padding: 8px;
      min-height: 100px;
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      resize: vertical;
      overflow-y: auto;
      width: calc(100% - 18px);
      color: #666;
    }

    #replyBox:read-only {
      background: #f8f9f9;
      cursor: not-allowed;
    }

    #replyBox:not(:read-only) {
      background: white;
      cursor: text;
      color: #000;
    }

    #replyBox:focus {
      outline: 2px solid #1f73b7;
      outline-offset: 1px;
    }

    #summaryBox {
      background: #f8f9f9;
      border: 1px solid #d8dcde;
      border-radius: 4px;
      padding: 8px;
      min-height: 100px;
      white-space: pre-wrap;
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.5;
    }

    hr {
      border: none;
      border-top: 1px solid #d8dcde;
      margin: 16px 0;
    }

    .collapse-section {
      margin-top: 12px;
      background-color: #cbcfd3;
      border-radius: 5px;
      padding: 10px;
    }

    .collapse-header {
      cursor: pointer;
      padding: 8px;
      background: #f8f9f9;
      border: 1px solid #d8dcde;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }

    .collapse-content {
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transform: translateY(-4px);
      transition:
        max-height 0.35s ease,
        opacity 0.25s ease,
        transform 0.25s ease;
    }

    .collapse-content.open {
      max-height: 500px;
      opacity: 1;
      transform: translateY(0);
    }

    .collapse-header:hover {
      background: #e8ebed;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
    }

    .arrow {
      transition: transform 0.2s;
    }

    .arrow.open {
      transform: rotate(90deg);
    }

    .edit-btn {
      margin-top: 6px;
      width: 100%;
      border: 1px solid #1f73b7;
      background: white;
      color: #1f73b7;
      border-radius: 4px;
      padding: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .edit-btn:hover {
      background: #e8f2f9;
    }

    .edit-btn.editing {
      background: #1f73b7;
      color: white;
    }
  </style>
</head>

<body>
  <h3>ü§ñ AI Ticket Assistant</h3>

  <!-- Collapsible Summary Section -->
  <div class="collapse-section">
    <div class="collapse-header" onclick="toggleSection('summarySection')">
      <span>üìù Ticket Summary</span>
      <span class="arrow" id="summaryArrow">‚ñ∂</span>
    </div>

    <div class="collapse-content" id="summarySection">
      <select id="summaryLanguage" class="secondary-btn">
        <option>Loading languages...</option>
      </select>

      <button id="summarizeBtn" class="primary-btn">
        Generate Summary
      </button>

      <div id="summaryBox">Click to generate summary...</div>
    </div>
  </div>

  <hr />

  <!-- Reply Composer Section -->
  <h4>AI Reply Composer</h4>

  <div class="tone-group">
    <label class="tone-pill">
      <input type="radio" name="tone" value="professional" /> Professional
    </label>
    <label class="tone-pill">
      <input type="radio" name="tone" value="friendly" /> Friendly
    </label>
    <label class="tone-pill">
      <input type="radio" name="tone" value="empathetic" /> Empathetic
    </label>
    <label class="tone-pill">
      <input type="radio" name="tone" value="apologetic" /> Apologetic
    </label>
    <label class="tone-pill">
      <input type="radio" name="tone" value="concise" /> Concise
    </label>
  </div>

  <button id="composeReplyBtn" class="primary-btn">Compose Reply</button>

  <div class="reply-container">
    <textarea id="replyBox" readonly placeholder="Reply will appear here..."></textarea>
    <button id="editReplyBtn" class="edit-btn" style="display: none;">
      ‚úèÔ∏è Edit Reply
    </button>
    <button id="copyReplyBtn" class="secondary-btn">
      üìã Copy to Reply Editor
    </button>
  </div>

  <script>
    // const BACKEND_URL = 'https://llm-replyer.onrender.com';
    const BACKEND_URL = 'http://localhost:3000';
    const client = ZAFClient.init();

    /* =========================
       UTILITIES
    ========================== */

    function toggleSection(sectionId) {
      const content = document.getElementById(sectionId);
      const arrow = document.getElementById(sectionId.replace('Section', 'Arrow'));
      content.classList.toggle('open');
      arrow.classList.toggle('open');
    }

    // Simple display formatter - backend now sends clean text
    function formatDisplay(text) {
      if (!text) return "";
      // Just add line breaks for display
      return text.replace(/\n/g, "<br>");
    }

    function showError(boxId, message) {
      const box = document.getElementById(boxId);
      if (box.tagName === 'TEXTAREA') {
        box.value = `‚ùå ${message}`;
      } else {
        box.innerHTML = `<span style="color: #cc0000;">‚ùå ${message}</span>`;
      }
    }

    /* =========================
       INITIALIZATION
    ========================== */

    // Store agent's locale and ticket locale globally
    let agentLocale = 'en-US'; // default
    let ticketLocale = 'en-US'; // default

    async function initLanguages() {
      try {
        const agent = await client.request('/api/v2/users/me.json');
        const localesRes = await client.request('/api/v2/locales/public.json');

        // Store agent's locale
        agentLocale = agent.user.locale;

        const dropdown = document.getElementById('summaryLanguage');
        dropdown.innerHTML = '';

        localesRes.locales.forEach(locale => {
          const opt = document.createElement('option');
          opt.value = locale.locale;
          opt.textContent = locale.name;

          if (locale.locale === agent.user.locale) {
            opt.selected = true;
          }

          dropdown.appendChild(opt);
        });
      } catch (e) {
        console.error('Failed to load languages', e);
        document.getElementById('summaryLanguage').innerHTML = '<option>English</option>';
      }
    }

    async function getCompleteTicketData() {
      const ticketData = await client.get('ticket');
      const ticketId = ticketData.ticket.id;

      const ticketResponse = await client.request(`/api/v2/tickets/${ticketId}.json`);
      const ticket = ticketResponse.ticket;

      // Get requester to determine ticket locale
      let requesterLocale = agentLocale;
      try {
        if (ticket.requester_id) {
          const requesterResponse = await client.request(`/api/v2/users/${ticket.requester_id}.json`);
          requesterLocale = requesterResponse.user.locale || agentLocale;
          ticketLocale = requesterLocale; // Store ticket locale globally
          console.log(`üìç Ticket locale detected: ${ticketLocale}`);
        }
      } catch (e) {
        console.warn('Could not fetch requester locale, using agent locale');
      }

      return {
        ticketId: ticket.id,
        subject: ticket.subject,
        description: ticket.description,
        status: ticket.status,
        priority: ticket.priority,
        tags: ticket.tags || [],
        locale: requesterLocale
      };
    }

    /* =========================
       TRANSLATE TEXT
    ========================== */

    async function translateText(text, targetLanguage) {
      try {
        console.log(`üåê Translating to ${targetLanguage}...`);
        
        const response = await client.request({
          url: `${BACKEND_URL}/translate`,
          type: "POST",
          contentType: "application/json",
          data: JSON.stringify({
            text: text,
            targetLanguage: targetLanguage
          }),
          cors: true
        });

        return response.translatedText;
      } catch (err) {
        console.error("Translation error:", err);
        throw err;
      }
    }

    /* =========================
       GENERATE SUMMARY
    ========================== */

    document.getElementById("summarizeBtn").addEventListener("click", async () => {
      const summaryBox = document.getElementById("summaryBox");
      const btn = document.getElementById("summarizeBtn");
      const language = document.getElementById("summaryLanguage").value;

      summaryBox.textContent = "Loading...";
      btn.disabled = true;

      try {
        const ticketData = await getCompleteTicketData();

        const response = await client.request({
          url: `${BACKEND_URL}/summarize`,
          type: "POST",
          contentType: "application/json",
          data: JSON.stringify({
            ...ticketData,
            language
          }),
          cors: true
        });

        summaryBox.innerHTML = formatDisplay(response.summary);

      } catch (err) {
        console.error("Summary error:", err);
        showError("summaryBox", "Failed to generate summary");
      } finally {
        btn.disabled = false;
      }
    });

    /* =========================
       COMPOSE REPLY
    ========================== */

    document.getElementById("composeReplyBtn").addEventListener("click", async () => {
      const replyBox = document.getElementById("replyBox");
      const editBtn = document.getElementById("editReplyBtn");
      const selectedTone = document.querySelector('input[name="tone"]:checked');
      const btn = document.getElementById("composeReplyBtn");

      if (!selectedTone) {
        showError("replyBox", "Please select a reply tone first");
        return;
      }

      replyBox.value = "Composing reply...";
      replyBox.readOnly = true;
      btn.disabled = true;
      editBtn.style.display = 'none';

      try {
        const ticketData = await getCompleteTicketData();

        const response = await client.request({
          url: `${BACKEND_URL}/compose-reply`,
          type: "POST",
          contentType: "application/json",
          data: JSON.stringify({
            ...ticketData,
            tone: selectedTone.value,
            language: agentLocale  // Pass agent's language
          }),
          cors: true
        });

        // Set the reply text
        replyBox.value = response.reply;
        replyBox.readOnly = true;
        
        // Show edit button
        editBtn.style.display = 'block';
        editBtn.textContent = '‚úèÔ∏è Edit Reply';
        editBtn.classList.remove('editing');

      } catch (err) {
        console.error("Reply error:", err);
        showError("replyBox", "Failed to compose reply");
      } finally {
        btn.disabled = false;
      }
    });

    /* =========================
       EDIT REPLY TOGGLE
    ========================== */

    document.getElementById("editReplyBtn").addEventListener("click", () => {
      const replyBox = document.getElementById("replyBox");
      const editBtn = document.getElementById("editReplyBtn");

      if (replyBox.readOnly) {
        // Enable editing
        replyBox.readOnly = false;
        replyBox.focus();
        editBtn.textContent = '‚úì Done Editing';
        editBtn.classList.add('editing');
      } else {
        // Disable editing
        replyBox.readOnly = true;
        editBtn.textContent = '‚úèÔ∏è Edit Reply';
        editBtn.classList.remove('editing');
      }
    });

    /* =========================
       COPY TO ZENDESK EDITOR (WITH TRANSLATION)
    ========================== */

    document.getElementById("copyReplyBtn").addEventListener("click", async () => {
      const replyBox = document.getElementById("replyBox");
      const copyBtn = document.getElementById("copyReplyBtn");
      const currentText = replyBox.value.trim();
      
      if (!currentText || currentText === "Reply will appear here...") {
        alert("‚ö†Ô∏è Please generate a reply first!");
        return;
      }

      try {
        // Disable button and show loading state
        copyBtn.disabled = true;
        copyBtn.textContent = "üîÑ Translating...";

        // Translate to ticket locale if different from agent locale
        let finalText = currentText;
        
        if (ticketLocale && ticketLocale !== agentLocale) {
          console.log(`üåê Translating from ${agentLocale} to ${ticketLocale}`);
          finalText = await translateText(currentText, ticketLocale);
          console.log(`‚úÖ Translation completed`);
        } else {
          console.log(`‚úì No translation needed (same locale: ${agentLocale})`);
        }

        // Copy to editor
        await client.invoke('ticket.comment.appendMarkdown', finalText);
        
        // Show success message
        copyBtn.textContent = "‚úÖ Copied!";
        setTimeout(() => {
          copyBtn.textContent = "üìã Copy to Reply Editor";
          copyBtn.disabled = false;
        }, 2000);

      } catch (err) {
        console.error("Copy error:", err);
        alert("‚ùå Failed to copy reply to editor");
        copyBtn.textContent = "üìã Copy to Reply Editor";
        copyBtn.disabled = false;
      }
    });

    /* =========================
       INITIALIZE
    ========================== */

    initLanguages();
    client.invoke('resize', { width: '100%', height: '560px' });
  </script>
</body>

</html>